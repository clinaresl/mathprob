// -*- coding: utf-8 -*-
// multiplication_table.go
//
// Description: Provides services for automatically generating multiplication
// tables
// -----------------------------------------------------------------------------
//
// Started on <lun 31-05-2021 20:00:08.961920795 (1622484008)>
// Carlos Linares LÃ³pez <carlos.linares@uc3m.es>
//

package mathtools

import (
	"bytes"
	"fmt"
	"log"
	"math/rand"
	"text/template"
	"time"

	"github.com/clinaresl/mathprob/helpers"
	"github.com/clinaresl/mathprob/mathtools/components"
)

// constants
// ----------------------------------------------------------------------------

// There are two different types of multiplication tables: "result" or
// "operand". In the first case, all operands are visible and the student has to
// provide the value of the result; in the latter, the result can be seen but
// one operand is missing whose value has to be guessed by the student
const (
	MTRESULT int = iota
	MTOPERAND
)

// the TikZ code for generating arbitrary multiplication tables is shown next.
// Note that it makes use of LaTeX/TikZ components
const latexMultiplicationTableCode = `\begin{minipage}{\linewidth}
    \begin{center}
        \begin{tikzpicture}

            {{.GetTikZPicture}}

        \end{tikzpicture}
    \end{center}
\end{minipage}
`

// The LaTeX/TikZ code used for darwing a single line of a multiplication table
// is shown next
const tikZMultiplicationTableLineCode = `
      % ----------------------------------------------------------------------------------

      {{.Operand1}}

      {{.Times}}

      {{.Operand2}}

      {{.Equal}}

      {{.Result}}
`

// The LaTeX/TikZ code used for drawing multiplication tables is generated by
// drawing each line separately
const tikZMultiplicationTableCode = `% --- Bottom ----------------------------------------------------------

      % Lower-left corner of the bounding box
      {{.Bottom}}

      % --- Lines of the multiplication table -------------------------------
      {{.GetLines}}
`

// types
// ----------------------------------------------------------------------------

// A multiplication table consists of 10 different rows where the same number is
// multiplied by geq, geq + 1, ... leq. If not given, the values of geq and leq
// should be 1 and 10 by default. The definition of a multiplication table
// includes the number of digits used in the factor repeated in all rows. Other
// options are whether the factors are presented in the usual order: 5x1
// (inv=false) or 1x5 (inv=true) and also whether the rows are sorted or not
// ---field sort. If inv is enabled it is randomly chosen whether each row is
// shown in the regular or inversed order

// In addition, there are two different types of multiplication tables:
//
//    0: both operands are given and the student has to guess the result
//    1: only one operand is given, and the student has to guess the value of
//    the other operand so that the equality holds
type multiplicationTable struct {
	mttype   int
	nbdigits int
	geq, leq int
	inv      bool
	sorted   bool
}

// the following struct stores all the information necessary to draw
// one single line of a multiplication table
type multiplicationTableLineTikZ struct {

	// each line consists of two operands
	Operand1, Operand2 components.CoordinatedText

	// and also the multiplication and equal symbols
	Times, Equal components.CoordinatedText

	// and they also open some space for either guessing or showing the answer
	Result components.CoordinatedText
}

// A multiplication table is just a slice of lines along with the bounding box
// to draw them all
type multiplicationTableTikZ struct {

	// the lower left corner of the bounding box is located always at (0,0). It
	// is used not only for creating the bounding box but also to serve as a
	// reference point for some items of the picture
	Bottom components.Coordinate

	// the lines of the multiplication table are stored in the next attribute.
	// Each one is drawn separately
	lines []multiplicationTableLineTikZ
}

// methods
// ----------------------------------------------------------------------------

// -- multiplicationTableTikZ

// Return the LaTeX/TikZ commands that show up the entire picture stored in the
// receiver
func (tikz multiplicationTableTikZ) GetLines() string {

	// Use a btyes buffer to append the strings of each line
	var output bytes.Buffer

	// First, add all lines
	for _, line := range tikz.lines {
		fmt.Fprintf(&output, "%v\n", line)
	}

	// and return the concatenation of the LaTeX/TikZ code used for drawing all
	// lines
	return output.String()
}

func (tikz multiplicationTableTikZ) execute() string {

	// create a template with the TikZ code for showing this picture
	tpl, err := template.New("multiplicationTableTikZ").Parse(tikZMultiplicationTableCode)
	if err != nil {
		log.Fatal(err)
	}

	// and now make the appropriate substitutions. Note that the execution of
	// the template is written to a string
	var tplOutput bytes.Buffer
	if err := tpl.Execute(&tplOutput, tikz); err != nil {
		log.Fatal(err)
	}

	// and return the resulting string
	return tplOutput.String()
}

// -- multiplicationTableLineTikZ

// Each line of a multiplication table is a stringer so their contents can be
// automatically printed using LaTeX/TikZ commands
func (tikz multiplicationTableLineTikZ) String() string {

	// create a template with the TikZ code for showing this picture
	tpl, err := template.New("multiplicationTableLineTikZ").Parse(tikZMultiplicationTableLineCode)
	if err != nil {
		log.Fatal(err)
	}

	// and now make the appropriate substitutions. Note that the execution of
	// the template is written to a string
	var tplOutput bytes.Buffer
	if err := tpl.Execute(&tplOutput, tikz); err != nil {
		log.Fatal(err)
	}

	// and return the resulting string
	return tplOutput.String()
}

// -- multiplicationTable

// return the instance of a specific basic multiplication table that can be
// marshalled in JSON format. The receiver is assumed to have been fully
// verified so that it should be consistent.
//
// The result is given as an array of numbers:
//    1. The first string is the number used in the multiplication table
//    2. Next, all items of each row are given in sorted order, e.g., "5", "1",
//    "5" which stands for "5x1=5". If one item has to be guessed it is shown as
//    a question mark "?"
func (mt multiplicationTable) generateJSONProblem() (problemJSON, error) {

	rand.Seed(time.Now().UTC().UnixNano())

	// first, determine the factor to use in all rows of the multiplication
	// table
	factor := helpers.RandN(mt.nbdigits)

	// now, make room to store the full solution of the multiplication table. In
	// total (1+leq-geq) rows have to be generated, each with three digits and
	// write down the number used in the multiplication table
	solution := make([]string, 1+(1+mt.leq-mt.geq)*3)
	solution[0] = fmt.Sprintf("%v", factor)

	// fill in the table
	for i := mt.geq; i <= mt.leq; i++ {

		// compute the relative position of this number
		idx := i - mt.geq

		// store the values in the solution with the usual order
		solution[1+idx*3] = fmt.Sprintf("%v", factor)
		solution[2+idx*3] = fmt.Sprintf("%v", i)

		// if the inverted presentation of factors was requested then randomly
		// determine whether to write the factor first or later
		if mt.inv {

			// if a number randomly generated in the interval [0, 100) falls in
			// the first half, then reverse the operands
			if rand.Int()%100 < 50 {
				solution[1+idx*3], solution[2+idx*3] = solution[2+idx*3], solution[1+idx*3]
			}
		}

		// in both cases, write down the result next
		solution[3+idx*3] = fmt.Sprintf("%v", factor*i)
	}

	// In case sorted is false, then shuffle all items in the multiplication
	// table
	if !mt.sorted {

		// For this, shuffle a slice of ints with the indexes of each row
		identity := make([]int, 10)
		for i := 0; i < 10; i++ {
			identity[i] = i
		}

		// and now shuffle them
		rand.Shuffle(len(identity),
			func(i, j int) {
				identity[i], identity[j] = identity[j], identity[i]
			})

		// now, affect the order of the solution as specified in the shuffled
		// slice. Note that as this is a destructive operation over solution, a
		// copy is necessary
		isolution := make([]string, len(solution))
		copy(isolution, solution)
		for i := 0; i < 10; i++ {
			solution[1+i*3], solution[2+i*3], solution[3+i*3] =
				isolution[1+identity[i]*3], isolution[2+identity[i]*3], isolution[3+identity[i]*3]
		}
	}

	// once the multiplication table has been fully generated, it is now the
	// turn to create the specific instance determining what numbers are hidden.
	// Note that the arguments preserve the first value, the factor used in the
	// multiplication table
	args := make([]string, 1+(1+mt.leq-mt.geq)*3)
	args[0] = solution[0]
	for i := 0; i < 1+mt.leq-mt.geq; i++ {

		// in case this is an ordinary multiplication table, just create the
		// instance as usual
		if mt.mttype == MTRESULT {
			args[1+i*3], args[2+i*3] = solution[1+i*3], solution[2+i*3]
			args[3+i*3] = "?"
		} else {

			// randomly determine what operand to mask. Tentaively, preserve the
			// first operand and the result
			args[1+i*3], args[3+i*3] = solution[1+i*3], solution[3+i*3]
			args[2+i*3] = "?"

			// if a number randomly generated in the interval [0, 100) falls in
			// the first half then mask the first operand instead
			if rand.Int()%100 < 50 {

				args[2+i*3], args[3+i*3] = solution[2+i*3], solution[3+i*3]
				args[1+i*3] = "?"
			}
		}
	}

	// Now, generate the multiplication table
	return problemJSON{
		Probtype: "MultiplicationTable",
		Args:     args,
		Solution: solution,
	}, nil
}

// return a valid LaTeX/TikZ representation of this multiplication table using
// TikZ components
func (mt multiplicationTable) GetTikZPicture() string {

	// -- operands: randomly determine the values of the operands and answers.
	// For this, the service that generates problems is the one that can marshal
	// them into JSON format. The operands and the result are given in Args,
	// where a question mark is a number that has to be guessed by the student
	instance, err := mt.generateJSONProblem()
	if err != nil {
		log.Fatalf(" Fatal error while generating a valid multiplication table: %v", err)
	}

	// compute the number of digits required to draw all operands in the first
	// and third column, and also to align all answers. These are all stored in
	// a slice
	nbdigits := []int{0, 0, 0}
	for idx := 1; idx < len(instance.Solution); idx += 3 {

		// update the maximum number of digits required to center all numbers in
		// the first, third and fifth column ---which result because the second
		// and fourth are taken by the multiplication and equal symbols
		for jdx := 0; jdx < 3; jdx++ {
			number, _ := helpers.Atoi(instance.Solution[idx+jdx])
			nbdigits[jdx] = int(helpers.Max(float64(nbdigits[jdx]),
				float64(helpers.NbDigits(number))))
		}
	}

	// -- bottom

	// Bottom is the lower-left corner of the bounding box
	bottom := components.NewCoordinate(components.Point{
		X: 0.0,
		Y: 0.0,
	}, "bottom")

	// -- lines of the multiplication table

	// next each line of the multiplication table is stored in a slice. Note
	// that the slice is created with no items because they will be appended
	lines := make([]multiplicationTableLineTikZ, 0)
	for idx := len(instance.Args) - 1; idx >= 1; idx -= 3 {

		// drawing the (idx-1) line in the slice of arguments which corresponds
		// with the i-th line in the multiplication table. i is counted from 1!
		i := 2 + mt.leq - mt.geq - idx/3

		// create the different items of the i-th line (base 1)

		// -- operand1
		//
		// if it has to be guessed by the student, then draw a rectangle to
		// write the solution whose width equals the number of digits of this
		// column plus 2; otherwise, write the number.
		options, text := "", ""
		if instance.Args[idx-2] == "?" {
			options = fmt.Sprintf(`rounded corners, rectangle, minimum width=%v\zerowidth, minimum height = \zeroheight + \baselineskip, draw`,
				2+nbdigits[0])
		} else {
			text = fmt.Sprintf(`\huge %v`, instance.Args[idx-2])
		}

		// when creating the operand, compute its label, opi1, where i has to be
		// properly substituted
		op1 := components.NewCoordinatedText(
			components.NewCoordinate(
				components.Formula(fmt.Sprintf(`$(bottom) + (%v\zerowidth, %v\zeroheight+%v\baselineskip)$`,
					(2.0+float64(nbdigits[0]))/2.0,
					float64(i)-0.5,
					0.5*(3*float64(i)-1))),
				fmt.Sprintf("op%v1", i)),
			options,
			text)

		// -- operator1
		//
		// The first operator is always the multiplication symbol
		times := components.NewCoordinatedText(
			components.NewCoordinate(
				components.Formula(fmt.Sprintf(`$(op%v1) + (%v*\zerowidth, 0.0)$`,
					i,
					1+(2.0+float64(nbdigits[0]))/2.0)),
				fmt.Sprintf("operator%v", i)),
			"",
			`\huge $\times$`)

		// -- operand2
		//
		// the second operand is computed much in the same way than the first
		// operand, the only difference being that its label is opi2
		options, text = "", ""
		if instance.Args[idx-1] == "?" {
			options = fmt.Sprintf(`rounded corners, rectangle, minimum width=%v\zerowidth, minimum height = \zeroheight + \baselineskip, draw`,
				2+nbdigits[1])
		} else {
			text = fmt.Sprintf(`\huge %v`, instance.Args[idx-1])
		}

		// when creating the operand, compute its label, opi1, where i has to be
		// properly substituted
		op2 := components.NewCoordinatedText(
			components.NewCoordinate(
				components.Formula(fmt.Sprintf(`$(operator%v) + (%v*\zerowidth, 0.0)$`,
					i,
					1+(2.0+float64(nbdigits[1]))/2.0)),
				fmt.Sprintf("op%v2", i)),
			options,
			text)

		// -- equal
		//
		// the equal symbol is created much in the same way than the
		// multiplication symbol
		equal := components.NewCoordinatedText(
			components.NewCoordinate(
				components.Formula(fmt.Sprintf(`$(op%v2) + (%v*\zerowidth, 0.0)$`,
					i,
					1+(2.0+float64(nbdigits[1]))/2.0)),
				fmt.Sprintf("equal%v", i)),
			"",
			`\huge $=$`)

		// -- result
		//
		// finally, the result is computed much in the same way than the
		// operands, with the only exception that its width is found in the
		// third item of nbdigits
		options, text = "", ""
		if instance.Args[idx] == "?" {
			options = fmt.Sprintf(`rounded corners, rectangle, minimum width=%v\zerowidth, minimum height = \zeroheight + \baselineskip, draw`,
				2+nbdigits[2])
		} else {
			text = fmt.Sprintf(`\huge %v`, instance.Args[idx])
		}

		// when creating the operand, compute its label, opi1, where i has to be
		// properly substituted
		answer := components.NewCoordinatedText(
			components.NewCoordinate(
				components.Formula(fmt.Sprintf(`$(equal%v) + (%v*\zerowidth, 0.0)$`,
					i,
					1+(2.0+float64(nbdigits[2]))/2.0)),
				fmt.Sprintf("answer%v", i)),
			options,
			text)

		// finally, create a new line and add it to the slice of lines to draw
		lines = append(lines, multiplicationTableLineTikZ{
			Operand1: op1,
			Times:    times,
			Operand2: op2,
			Equal:    equal,
			Result:   answer,
		})
	}

	// And put all these elements together to show up the picture of a
	// multiplication table
	mtPicture := multiplicationTableTikZ{
		Bottom: bottom,
		lines:  lines,
	}

	// and return the TikZ code necessary for drawing the problem
	return mtPicture.execute()
}

// Return TikZ code that represents a sequence
func (mt multiplicationTable) execute() string {

	// create a template with the TikZ code for showing this multiplication table
	tpl, err := template.New("multiplicationTable").Parse(latexMultiplicationTableCode)
	if err != nil {
		log.Fatal(err)
	}

	// and now make the appropriate substitutions. Note that the execution of the
	// template is written to a string
	var tplOutput bytes.Buffer
	if err := tpl.Execute(&tplOutput, mt); err != nil {
		log.Fatal(err)
	}

	// and return the resulting string
	return tplOutput.String()
}

// Local Variables:
// mode:go
// fill-column:80
// End:
